|        size         | v | b | l历史/预测长度 | k复数长度 | a | b(1) | c |
|:-------------------:| :--: | :--: |:--------:|:-----:| :--: | :--: | :--: |
| H_D_pre_train | 900 | 10 |    4     |  48   | 4 | 4 | 2 |
| H_U_pre_train | 900 | 10 |    4     |  48   | 4 | 4 | 2 |
| H_U_his_train | 900 | 10 |    16    |  48   | 4 | 4 | 2 |

---
在调用时，输入是尺寸为[8100,16,1536]的张量，输出是尺寸为[259200，16，96]的张量

假设你调用时输入的张量 `H` 的尺寸为 `[8100, 16, 1536]`，输出张量的尺寸是 `[259200, 16, 96]`，我们可以从代码的执行步骤来推测这些尺寸是如何变化的。

### 输入张量尺寸分析
- 输入张量 `H` 的尺寸为 `[8100, 16, 1536]`，这里：
  - `8100` 代表批量大小 `B`。
  - `16` 代表时间步数 `T`。
  - `1536` 代表信号的维度 `mul`。

### 代码中的重排操作
`H` 被重排的关键操作是：
```python
H = rearrange(H, 'b t (k a) ->(b a) t k', a=num)
```

这行代码的作用是将 `H` 的最后一个维度 `mul` 切分成 `num` 个小块。因此，在执行重排时，`mul` 将被拆分成 `num` 组，每组的大小为 `mul // num`。

#### 推算重排后的维度：
- 假设 `num = 32`，那么 `mul = 1536` 会被切分成 32 份，每份的大小为：
  \[
  mul // num = 1536 // 32 = 48
  \]
- 经过重排后，`H` 的尺寸将变为：
  \[
  (8100 * 32, 16, 48) = (259200, 16, 48)
  \]
  这里，`8100` 被乘以 `32`，因此得到的新维度为 `[259200, 16, 48]`。

### 创建 `H_real` 数组
接下来，我们创建 `H_real` 数组的尺寸：
```python
H_real = np.zeros([B * num, T, mul // num, 2])
```
这个 `H_real` 数组的尺寸为 `[259200, 16, 48, 2]`，其中 `2` 用于存储实部和虚部。

### 填充实部和虚部
在填充实部和虚部后，`H_real` 会有两个通道（实部和虚部）：
```python
H_real[:, :, :, 0] = H.real
H_real[:, :, :, 1] = H.imag
```

此时，`H_real` 的尺寸仍为 `[259200, 16, 48, 2]`，不过现在它包含了实部和虚部。

### 调整形状
最后，`H_real` 会被重塑为：
```python
H_real = H_real.reshape([B * num, T, mul // num * 2])
```
即：
\[
H_real = H_real.reshape([259200, 16, 96])
\]
这里，`mul // num * 2` 就是 `48 * 2 = 96`，因此最终的张量尺寸为 `[259200, 16, 96]`。

### 总结
- **输入**：尺寸为 `[8100, 16, 1536]` 的张量 `H`。
- **输出**：经过上述处理后，输出的张量 `H_real` 的尺寸为 `[259200, 16, 96]`。
  
在整个过程中，输入张量的 `mul` 被切分为 `num` 组，分别存储复数的实部和虚部，最终形成一个实数张量，其中的最后一个维度将会是 `mul // num * 2`。